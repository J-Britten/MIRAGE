#pragma kernel CSMain

#include "SegmentationCommon.hlsl"

//
// This shader implements a Kuwahara filter for segmentation masks.
// We pass the filter radius, number of sectors, and strength as color values r, g, and b respectively in the classColor variable.

RWTexture2D<float4> Result;
Texture2D<float4> InputTexture;
StructuredBuffer<int2> outputArray;
StructuredBuffer<float> objectDepths;
int width;
int height;
uint inputWidth;
uint inputHeight;

float3 rgb2lab(float3 rgb) {
    float3 xyz = float3(
        0.412453f * rgb.r + 0.357580f * rgb.g + 0.180423f * rgb.b,
        0.212671f * rgb.r + 0.715160f * rgb.g + 0.072169f * rgb.b,
        0.019334f * rgb.r + 0.119193f * rgb.g + 0.950227f * rgb.b
    );
    
    xyz.x /= 0.95047f;
    xyz.y /= 1.0f;
    xyz.z /= 1.08883f;
    
    xyz = xyz > 0.008856f ? pow(xyz, float3(1.0f/3.0f, 1.0f/3.0f, 1.0f/3.0f)) : (7.787f * xyz + 16.0f/116.0f);
    
    return float3(
        116.0f * xyz.y - 16.0f,
        500.0f * (xyz.x - xyz.y),
        200.0f * (xyz.y - xyz.z)
    );
}

float3 lab2rgb(float3 lab) {
    float y = (lab.x + 16.0f) / 116.0f;
    float x = lab.y / 500.0f + y;
    float z = y - lab.z / 200.0f;
    
    float3 xyz = float3(x, y, z);
    xyz = xyz * xyz * xyz > 0.008856f ? xyz * xyz * xyz : (xyz - 16.0f/116.0f) / 7.787f;
    
    xyz.x *= 0.95047f;
    xyz.y *= 1.0f;
    xyz.z *= 1.08883f;
    
    float3 rgb = float3(
        3.2406f * xyz.x - 1.5372f * xyz.y - 0.4986f * xyz.z,
        -0.9689f * xyz.x + 1.8758f * xyz.y + 0.0415f * xyz.z,
        0.0557f * xyz.x - 0.2040f * xyz.y + 1.0570f * xyz.z
    );
    
    return saturate(rgb);
}

float4 kuwaharaFilter(int2 coord, int radius, int sectors, float strength) {
    float3 meanColor[16]; // Increased max array size to handle up to 16 sectors
    float variance[16];
    float weightSum[16];
    
    [unroll]
    for(int k = 0; k < sectors; k++) {
        meanColor[k] = float3(0, 0, 0);
        variance[k] = 0;
        weightSum[k] = 0;
    }
    
    // First pass: calculate means
    for(int i = -radius; i <= radius; i++) {
        for(int j = -radius; j <= radius; j++) {
            int2 offset = int2(i, j);
            int2 samplePos = coord + offset;
            
            if(samplePos.x >= 0 && samplePos.x < inputWidth && 
               samplePos.y >= 0 && samplePos.y < inputHeight) {
                
                float r = length(float2(i, j));
                if(r <= radius) {
                    float angle = atan2(float(j), float(i)) + 3.14159f;
                    int sector = int(floor((angle / (2 * 3.14159f)) * sectors));
                    float w = exp(-r * r / (2 * strength * strength));
                    
                    float4 color = InputTexture[samplePos];
                    float3 lab = rgb2lab(color.rgb);
                    
                    meanColor[sector] += lab * w;
                    weightSum[sector] += w;
                }
            }
        }
    }
    
    // Normalize means and calculate variances
    [unroll]
    for(int k = 0; k < sectors; k++) {
        if(weightSum[k] > 0) {
            meanColor[k] /= weightSum[k];
        }
    }
    
    // Second pass: calculate variances
    for(int i = -radius; i <= radius; i++) {
        for(int j = -radius; j <= radius; j++) {
            int2 offset = int2(i, j);
            int2 samplePos = coord + offset;
            
            if(samplePos.x >= 0 && samplePos.x < inputWidth && 
               samplePos.y >= 0 && samplePos.y < inputHeight) {
                
                float r = length(float2(i, j));
                if(r <= radius) {
                    float angle = atan2(float(j), float(i)) + 3.14159f;
                    int sector = int(floor((angle / (2 * 3.14159f)) * sectors));
                    float w = exp(-r * r / (2 * strength * strength));
                    
                    float4 color = InputTexture[samplePos];
                    float3 lab = rgb2lab(color.rgb);
                    float3 diff = lab - meanColor[sector];
                    variance[sector] += dot(diff, diff) * w;
                }
            }
        }
    }
    
    // Find sector with minimum variance
    float minVariance = 1e10;
    float3 finalColor = float3(0, 0, 0);
    
    [unroll]
    for(int k = 0; k < sectors; k++) {
        if(weightSum[k] > 0) {
            variance[k] /= weightSum[k];
            
            if(variance[k] < minVariance) {
                minVariance = variance[k];
                finalColor = meanColor[k];
            }
        }
    }
    
    return float4(lab2rgb(finalColor), 1.0);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= inputWidth || id.y >= inputHeight) return;

    float scaleX = (float)width / inputWidth;
    float scaleY = (float)height / inputHeight;
    
    int outputX = (int)(id.x * scaleX);
    int outputY = (int)(id.y * scaleY);
    
    int outputIndex = outputY * width + outputX;
    int2 c = outputArray[outputIndex];
    int objectId = c.x;
    int classIndex = c.y;
    float depth = objectDepths[objectId];

    int2 inputCoord = int2(id.x, inputHeight - 1 - id.y);
    
    float4 existingColor = Result[inputCoord];
    if (existingColor.a > 0)
    {
        return;
    }
    
    float4 classColor = GetColorForClassAndDepth(classIndex, depth);
    if (classColor.r > 0)
    {
        // Extract parameters from color channels (multiplied by 255 to get original values)
        int filterRadius = int(clamp(classColor.r * 255, 1, 5)); 
        int sectors = int(clamp(classColor.g * 255, 4, 16)); 
        float strength = (classColor.b * 255) ; 
        
        float4 filteredColor = kuwaharaFilter(inputCoord, filterRadius, sectors, strength);
        Result[inputCoord] = float4(filteredColor.rgb, 1);
    }
    else if(Result[inputCoord].a == 0)
    {
        Result[inputCoord] = float4(0, 0, 0, 0);
    }
}
